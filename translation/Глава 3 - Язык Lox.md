# Глава 3 - Язык Lox

> Что еще приятного вы можете сделать для человека, кроме как приготовить ему завтрак?
> Anthony Bourdain

Мы посвятим остаток этой книги освещения каждого темного и разного угла языка Lox, но 
кажется жестоким, что вы немедленно начнете выдалбливать код для интерперетатора, не имя хотя бы
малейшего представления о том, что мы получим в итоге.

В то же время, я не хочу тащить вас чере кучу языковых юридических 
и спецификационных вопросов, прежде чем вы прикоснетесь к своему текстовому редакторку.
Так что это будет мягкое, дружелюбное введение в Lox. Оно опутсти много деталей и пограничных
случае. У нас будет достаточно времени для этого позже

## 3.1 Привет, Lox
Вот ваш первый код на Lox
```
// Ваша первая программа на Lox
print "Hello, world!"
```

Как и подразумевается в этом комментарии `//` и точке с запятой в конце, синтаксис Lox является членом
семейства C. (Вокргу строки нет скоробок, потому что `print` - встроенный оператор, а не библиотечная функция.)

Теперь я не буду утверждать, что у С отличный синтаксис. Если бы мы хотели чего-то элегантного, мы, веротяно,
подражали бы Pascal или Smalltalk. Если бы мы хотели полностью последовать скандинавскому минимализму - мебели
мы бы использовали `Scheme`. У всех есть свои достоинства.

Вместо этого в синтаксисе, похожем на C, есть то, что вы часто найдете более ценным для вас - _знакомость_. 
Я знаю, что вы уже освоились с этим стилем, потому что два языка, которые мы будем использовать для реализации
Lox - Java и C - также унаследовали его. Использование похожего синтаксиса для Lox позволяет вам изучать на
одну вещь меньше.

## 3.2 Высокоуровневый язык
Хотя книга получилась больше, чем я надеялся, она все еще недостатчоно велика, чтоб вместить в нее 
таккой огромный язык, как Java. Чтобы вместтить две полные реализации Lox на этих страницах,
сам Lox должен быть доволно компактным.

Когда я думаю о языках, которые являются небольшими, но полезными, на ум приходят высокоуровненвые 
"скриптовые"языки, такие как JavaScript, Scheme и Lua. Из этих трех Lox больше всего похож на JavaScript, 
в основмно потому, что большинство языков с синтаксисом C так и делают. Как мы узнаем позже подход Lox
к области действия тесно связан со Scheme. Вариант  C Lox, который мы создадим в третьей части, во многом
обязан чистой и эффективноей реализации Lua.

Lox разделяет два других аспект с этими тремя языками.

### 3.2.1 Динамическая типизация
### 3.2.2 Автоматическое управление памятью
## 3.3 Типы данных
В маленькой вселенной язык Lox, атомы создают всю материю, которая построена на типах данных.
Рассмотрим несколько из них

##### Booleans
```
true
false
```
##### Numbers
```
1234
12.34
```
##### Strings
```
"I am a string";
"";
"123";
```

##### Nil

## 3.4 Выражения
### 3.4.1 Арифметические
### 3.4.2 Сравнение и равенство
### 3.4.3 Логические операции
### 3.4.4 Приоритет и группировка
## 3.5 Операторы
## 3.6 Переменные
## 3.7 Управление ходом выполнения
## 3.8. Функции
### 3.8.1 Closures
## 3.9. Классы
### 3.9.1 Почему каждый язык может быть хотеть объектно - ориентированным
### 3.9.2 Почему Lox объектно - ориентированный?

Я мог бы утверждать, что объекты хороши, но все еще выходят за рамки книги. 
Большинство книг по языкам программирования, особенно те, которые пытаются реализовать целый язык,
оставляют объекты в стороне. Для меня это означает, что эта тема недостаточно хорошо освещена. 
При такой распространненой парадигме это упущение огорчает меня.

Учитывая, сколько из нас проводят весь день, используя ООП языки, похоже, что миру не 
помешала бы небольшая документация о том, как это сделать. Как вы увидите, это
оказывается довольно интересны. Не так сложно, как вы бы могли подумать, но
и не так просто, как вы бы могли предположить.

### 3.9.3 Классы или прототипы

Когда дело доходит до объектов, на самом деле есть два подхода к ним:
- Классы
- Прототипы

Классы появились первыми и стали более распространнеными благодаря C++, Java, C# и друзьям.
Прототипы были практически забытым явлением, пока JavaScript случайно не захватил мир.

В языках, основанных на классах, есть два основных концепта:
- Экземпляры
- Классы

Экземпляры хранят состоние для каждого объекта и ссылаются на экземпляры. Классы содержат
методы и цепочку наследования. Чтобы вызывать метод для экземпляра, всегда есть уровень указания.
Вы ищите класс экземпляра, а затем находит там метод.

[//]: # (TODO: Добавить схему)

Языне на основе прототипов объединяет эти два концепта. Есть только объекты - никаких классов
и каждый отдельный объект может содержать состояния и методы. Объекты могут напрямую взаимодействовать
друг с другом (или **делегировать** на языке прототипов)

[//]: # (TODO добавить схему)

Это означает, что в некотором смысле прототипные языки более фнудатментальны, чем классы.
Их действительно удобно реализовывать, потому что они очень просты. Кроме того, они могут
выражать множество необычных шаблонов, от которых вас уводят классы.

Но я просмотрел на множество кода, написанного на прототипных языках, включая свой собственный. 
Знаете, что люди обычно делают со всей мощью и гибкостью прототипов?...Используют их
для переосмысления классов.

Я не знаю, почему так, но люди, по видимому, предпочитают стиль, основанный на классах.
Прототипы проще в языке, но они похоже, достигаю этого, только перекладывая сложность
на пользователя. Так что для Lox мы избавим наших пользователей от хопот и сразу же 
включим классы.

### 3.9.4 Класссы в Lox

Достатчного обоснований, давайте посмотрим, что у нас есть. Классы охватывают
созведние функций в большинстве языков. Для Lox я выбрал то, что по моему мнению
является самыми яркими звездами. Вы объявляете класс и методы так

```
class Breakfast {
    cook() {
        print "Eggs -afrying'!";
    }
    
    serve(who) {
        print "Enjoy your breakfast, " + who + ".";
    }
}
```

Тело класса содержати его методы. Они выглядят как объявления функций, но без
ключевого слова `fun`. Когда выполняется объявление класса, Lox создает объекты
класса и сохраняет их в переменной, названной в честь класса. Так же, как и фнукции,
классы являются _гражданами первого класса_ (first class citizen)

```
// Сохранить значение в переменную
var someVariable = Breakfast;

// Передать класс в функцию
someFunction(Breakfast);
```

Далее нам нужен способ создания экземпляров. Мы могли бы добавить какое-то новое
ключевое слово, но для просты в Lox сам класс является фабричной функций для экземпрялов.

```
var breakfast = Breakfast();
print breakfast; //Brekfast instance
```

### 3.9.5 Создание и инициализация

Классы, которые имеют только поведение, не очень полезны. Идея объектно - ориентированного
программирования заключается в инкапсуляции поведения и состония вместе. Для этого 
вам нужны поля. Lox, как и другие динамически типизированные языки, позволяет
вам свободно добавлять свойства к объектам.

```
breakfast.meat = "sausage";
breakfast.bread = "sourdough";
```

Присвоение полю создает его, если оно еще не сущетвует.
Если вы хоитет получить доступ к полю или методу текущего объекта из метода,
вы должно использовать старый добрый `this`.

```
class Breakfast {
    
    serve(who) {
        print "Enjoy your " + this.meat + " and " + this.bread + ", " +  who + ".";
    }
}
```

Частью инкапсуляции данных в объект является обеспечение того, что объект находится 
в допустимом состоянии при его создании. Для этого можно определить инициализатор.
Если в вашем классе есть метод с именем `init()`, он вызывается автоматичеси при создании
объекта. Любые параметры, переданные классу, перенаправляются в инициализатор.


```
class Breakfast {
  init(meat, bread) {
      this.meat = meat;
      this.bread = bread;
  }
}


var baconAndToast = Breakfast("bacon", "toast");
bacondAndToast.serve("Дорогой читатель");
```

### 3.9.6 Наследование

[Предыдущая глава](Глава%202%20-%20Карта%20терриотории.md)