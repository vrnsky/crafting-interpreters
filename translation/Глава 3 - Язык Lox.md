# Глава 3 - Язык Lox

> Что еще приятного вы можете сделать для человека, кроме как приготовить ему завтрак?
> Anthony Bourdain

Мы посвятим остаток этой книги освещения каждого темного и разного угла языка Lox, но 
кажется жестоким, что вы немедленно начнете выдалбливать код для интерперетатора, не имя хотя бы
малейшего представления о том, что мы получим в итоге.

В то же время, я не хочу тащить вас чере кучу языковых юридических 
и спецификационных вопросов, прежде чем вы прикоснетесь к своему текстовому редакторку.
Так что это будет мягкое, дружелюбное введение в Lox. Оно опутсти много деталей и пограничных
случае. У нас будет достаточно времени для этого позже

## 3.1 Привет, Lox
Вот ваш первый код на Lox
```
// Ваша первая программа на Lox
print "Hello, world!"
```

Как и подразумевается в этом комментарии `//` и точке с запятой в конце, синтаксис Lox является членом
семейства C. (Вокргу строки нет скоробок, потому что `print` - встроенный оператор, а не библиотечная функция.)

Теперь я не буду утверждать, что у С отличный синтаксис. Если бы мы хотели чего-то элегантного, мы, веротяно,
подражали бы Pascal или Smalltalk. Если бы мы хотели полностью последовать скандинавскому минимализму - мебели
мы бы использовали `Scheme`. У всех есть свои достоинства.

Вместо этого в синтаксисе, похожем на C, есть то, что вы часто найдете более ценным для вас - _знакомость_. 
Я знаю, что вы уже освоились с этим стилем, потому что два языка, которые мы будем использовать для реализации
Lox - Java и C - также унаследовали его. Использование похожего синтаксиса для Lox позволяет вам изучать на
одну вещь меньше.

## 3.2 Высокоуровневый язык
Хотя книга получилась больше, чем я надеялся, она все еще недостатчоно велика, чтоб вместить в нее 
таккой огромный язык, как Java. Чтобы вместтить две полные реализации Lox на этих страницах,
сам Lox должен быть доволно компактным.

Когда я думаю о языках, которые являются небольшими, но полезными, на ум приходят высокоуровненвые 
"скриптовые"языки, такие как JavaScript, Scheme и Lua. Из этих трех Lox больше всего похож на JavaScript, 
в основмно потому, что большинство языков с синтаксисом C так и делают. Как мы узнаем позже подход Lox
к области действия тесно связан со Scheme. Вариант  C Lox, который мы создадим в третьей части, во многом
обязан чистой и эффективноей реализации Lua.

Lox разделяет два других аспект с этими тремя языками.

### 3.2.1 Динамическая типизация
### 3.2.2 Автоматическое управление памятью
## 3.3 Типы данных
В маленькой вселенной язык Lox, атомы создают всю материю, которая построена на типах данных.
Рассмотрим несколько из них

##### Booleans
```
true
false
```
##### Numbers
```
1234
12.34
```
##### Strings
```
"I am a string";
"";
"123";
```

##### Nil

## 3.4 Выражения
### 3.4.1 Арифметические
### 3.4.2 Сравнение и равенство
### 3.4.3 Логические операции
### 3.4.4 Приоритет и группировка
## 3.5 Операторы
## 3.6 Переменные
## 3.7 Управление ходом выполнения
## 3.8. Функции
### 3.8.1 Closures
## 3.9. Классы
### 3.9.1 Почему каждый язык может быть хотеть объектно - ориентированным
### 3.9.2 Почему Lox объектно - ориентированный?

Я мог бы утверждать, что объекты хороши, но все еще выходят за рамки книги. 
Большинство книг по языкам программирования, особенно те, которые пытаются реализовать целый язык,
оставляют объекты в стороне. Для меня это означает, что эта тема недостаточно хорошо освещена. 
При такой распространненой парадигме это упущение огорчает меня.

Учитывая, сколько из нас проводят весь день, используя ООП языки, похоже, что миру не 
помешала бы небольшая документация о том, как это сделать. Как вы увидите, это
оказывается довольно интересны. Не так сложно, как вы бы могли подумать, но
и не так просто, как вы бы могли предположить.

### 3.9.3 Классы или прототипы

Когда дело доходит до объектов, на самом деле есть два подхода к ним:
- Классы
- Прототипы

Классы появились первыми и стали более распространнеными благодаря C++, Java, C# и друзьям.
Прототипы были практически забытым явлением, пока JavaScript случайно не захватил мир.

В языках, основанных на классах, есть два основных концепта:
- Экземпляры
- Классы

Экземпляры хранят состоние для каждого объекта и ссылаются на экземпляры. Классы содержат
методы и цепочку наследования. Чтобы вызывать метод для экземпляра, всегда есть уровень указания.
Вы ищите класс экземпляра, а затем находит там метод.

[//]: # (TODO: Добавить схему)

Языне на основе прототипов объединяет эти два концепта. Есть только объекты - никаких классов
и каждый отдельный объект может содержать состояния и методы. Объекты могут напрямую взаимодействовать
друг с другом (или **делегировать** на языке прототипов)

[//]: # (TODO добавить схему)

Это означает, что в некотором смысле прототипные языки более фнудатментальны, чем классы.
Их действительно удобно реализовывать, потому что они очень просты. Кроме того, они могут
выражать множество необычных шаблонов, от которых вас уводят классы.

Но я просмотрел на множество кода, написанного на прототипных языках, включая свой собственный. 
Знаете, что люди обычно делают со всей мощью и гибкостью прототипов?...Используют их
для переосмысления классов.

Я не знаю, почему так, но люди, по видимому, предпочитают стиль, основанный на классах.
Прототипы проще в языке, но они похоже, достигаю этого, только перекладывая сложность
на пользователя. Так что для Lox мы избавим наших пользователей от хопот и сразу же 
включим классы.

### 3.9.4 Класссы в Lox

Достатчного обоснований, давайте посмотрим, что у нас есть. Классы охватывают
созведние функций в большинстве языков. Для Lox я выбрал то, что по моему мнению
является самыми яркими звездами. Вы объявляете класс и методы так

```
class Breakfast {
    cook() {
        print "Eggs -afrying'!";
    }
    
    serve(who) {
        print "Enjoy your breakfast, " + who + ".";
    }
}
```

Тело класса содержати его методы. Они выглядят как объявления функций, но без
ключевого слова `fun`. Когда выполняется объявление класса, Lox создает объекты
класса и сохраняет их в переменной, названной в честь класса. Так же, как и фнукции,
классы являются _гражданами первого класса_ (first class citizen)

```
// Сохранить значение в переменную
var someVariable = Breakfast;

// Передать класс в функцию
someFunction(Breakfast);
```

Далее нам нужен способ создания экземпляров. Мы могли бы добавить какое-то новое
ключевое слово, но для просты в Lox сам класс является фабричной функций для экземпрялов.

```
var breakfast = Breakfast();
print breakfast; //Brekfast instance
```

### 3.9.5 Создание и инициализация

Классы, которые имеют только поведение, не очень полезны. Идея объектно - ориентированного
программирования заключается в инкапсуляции поведения и состония вместе. Для этого 
вам нужны поля. Lox, как и другие динамически типизированные языки, позволяет
вам свободно добавлять свойства к объектам.

```
breakfast.meat = "sausage";
breakfast.bread = "sourdough";
```

Присвоение полю создает его, если оно еще не сущетвует.
Если вы хоитет получить доступ к полю или методу текущего объекта из метода,
вы должно использовать старый добрый `this`.

```
class Breakfast {
    
    serve(who) {
        print "Enjoy your " + this.meat + " and " + this.bread + ", " +  who + ".";
    }
}
```

Частью инкапсуляции данных в объект является обеспечение того, что объект находится 
в допустимом состоянии при его создании. Для этого можно определить инициализатор.
Если в вашем классе есть метод с именем `init()`, он вызывается автоматичеси при создании
объекта. Любые параметры, переданные классу, перенаправляются в инициализатор.


```
class Breakfast {
  init(meat, bread) {
      this.meat = meat;
      this.bread = bread;
  }
}


var baconAndToast = Breakfast("bacon", "toast");
bacondAndToast.serve("Дорогой читатель");
```

### 3.9.6 Наследование

Каждый объектно-ориентированный язык позволяет не только определять методы,
но и повторно использовать их в нескольких классах или объектах.
Для этого Lox поддерживает одиночное (не более 1) наследование.

Когда вы объявлете класс, вы можете указать класс, от которого он наследуется,
используя оператор меньше (<)

<details>
<summary> Почему выбран оператор < для обозначения наследования</summary>

Мне не хотелось вводить новое ключеове слово, например `extends`. Lox не использует `:`
для чего либо еще, поэтому я не хотел резервивровать его. Вместо этого я взял подход, который
принят в Ruby и использовал `<`

Если вы знакомы с какой-либо теорией типов, вы заметите, что это не полностью произвольный
выбор. Каждый экземпляр подкласса в экземпляре его суперкласса также, но
могут быть экземпляры суперкласса, которые не являются экземпляра подкласса.
Это означает, что во вселенной объектов набор объектов подкласса меньше набора суперкласса,
хотя фанаты типов обычно используют `<:` для описания такого типа отношения.
</details>

```
class Brunch < Breakfast {
    drink() {
        print "How about a Bloody Mary?";
    }
}
```

Здесь `Brunch` - **проивзодный класс** или **подкласс**, и `Breakfast` это **базовый** класс
или **суперкласс**.

```
var benedict = Brunch("ham", "English muffin");
benedict.serve("Noble Reader");
```

Даже метод `init()` наследуется. На практике подклассы обычно хочет определить
свой собсвтенный метод `init()`. Но исходный метод также должен быть вызван,
чтобы суперкласс мог поддерживать свое состояние. Нам нужен какой-то способ
вызвать метод в нашем собственном экземпляре, на затрагивая наши собственные методы.

<details>
<summary>Разница в наследовании конструкторов</summary>
Lox отличается от C++, Java, и C#, которые не наследуют конструкторы, но
похож на Smalltalk и Ruby, которые наследуют конструкторы.
</details>

Как и в Java, для этого будет использоваться ключевое слово `super`

```
class Brunch < Breakfast {
    init (meat, bread, drink) {
        super(meat, bread);
        this.drink = drink;
    }
}
```

Вот и все об объектной ориентации. Я старался свести набор функций к миниму.
Структура книги вынудила пойти на компромисс. Lox это не чистый объектно - ориентированный язык.
В настоящем ООП - языке каждый объект является экземпляром класса, даже примитивные значения,
такие как числа и булевы значения.

Поскольку мы не реализуем классы до тех пор, пока не начнем работать со встроенными типам,
это было было бы сложно. Поэтому значения примитивных типов не являются настоящими объектами
в том смысле, что они являеются экземплярами классов. У них нет методов и свойств.
Если бы мы пытались сделать Lox настоящим языком для настоящих пользователей,
то это стоило бы обязательно исправить.

## 3.10 Стандартная библиотека

Мы почти закончили. Это весь язык, так что все что осталось это "ядро" или "стандартная" библиотека -
набор функций, которые реализованы непосредственно в интерпретаторе и на которых строится
все определеяемое пользователем поведение.

Это самая грустная часть Lox. Его стандартная библиотека выходит за рамки минимализма и приближается
к прямому нигилизму. Для примера кода в книге нам нужно только продемонстрировать,
что код выполняется, и описать, что должен делать. Для этого у нас уже есть встроенный оператор печати.

Позже, когда мы начнем оптмизировать, мы напишем несколько тестов и посмотрим, сколько времений
займет выполнение кода. Это значит, что нам нужно отслеживать время, поэтому мы определим встроенную 
функцию `clock()`, которая возвращает количество секунд с момента запуска программы.

И...все. Я знаю, да? Это смущает.

Если вы хотите превратить Lox в дейтвительно полезный язык, то первое, что вам следует
сделать, это конкретизировать это.
Манипуляции со строками, тригонометрические функции, файловый ввод-ввыод, работае в сети, черт возьми, даже
чтение вывода от пользователя, помогло бы. Но нам ничего из этого не нужно для этой книги, и добавление
этого не научита вас ничему интересному, поэтому я это опустил.

Не волнуйтесь, у нас будет много захватывающих вещей в языке, 
которые останутся, чтобы занять нас.

## Задания

Напишите несколько примеров программ на Lox и запустите их (вы можете использовать реализацию Lox в моем репозитории).
Попробуйте придуть поведениче граничного случая, которо я здесь не указал. Делает ли оно то, что вы ожидаете?
Почему или почему нет?

Это введение оставляет много неопределенного перечислите несколько открытых вопросов, которые у вас есть о синтаксисе
и семантике языка. Какими, по вашему, должны быть ответы?

Lox - довольно маленький язык. Каких функций, по-вашему, в нем не хватает, что сделало бы его неудобным
для использования в реальных программах? (Кроме стандартной библиотеки, конечно)

## Заметки дизайнера языка: выражения и операторы

В Lox имееются как выражения, так и операторы. Некоторые языки опускают последнее, вместо этого
рассматривая декларации и конструкции потока управления как выражения Эти языки "все есть вырважение"
имеют, как правило функцональные родословные и включают большинство Lisp, SML, Haskel и CoffeeScript.

Чтобы сделать это, для каждой "подобной оператору" конструкции в язызке вам нужно решить, какое
значение она вычисляет. Некоторые из них просты

- Выражение if вычисляет в результате любой выбранной ветви. Аналогично, switch или multi-way ветвь вычисляется в любой выбранный случай
- Объявление переменной вычисляется в значение переменной
- Блок вычисляется в результат последнего выражения в последовательности

Некоторые вещи видятся немного странно. Что должен вычислять цикл? Цикл `while` в CoffeeScript вычисляет
массив, содержащий каждый элемент, который вычислял тело. Это может быть удобно или пустой тратой памяти,
если массив не нужен.

Вам также нужно решить, как эти выражения, подобные операторам, будут сочетаться с другими выражениями -
вам нужно вписать их в таблицу приоритетов грамматики. Например Ruby позволяет:

`puts 1 + if true then 2 else 3 end + 4`

Это то, чего вы ожидаете? Это то, чего ожидают ваши пользователи? Как это влияет на то, как 
вы проектируете синтаксис для ваших "операторов"? Обратите внимание, что в Ruby есть явный `end`, 
чтобы узкатьа, когда if выражение завершено. Без него `+ 4`, скорее всего будет проанализировано как продолжение
else.

Превращая каждый оператор в выражение, вы заставляете вас ответить на несколько сложных вопросы. Взамен
вы устраняете некоторую избыточность. В C есть оба блока для упорядочивания операторов и операторов запятой для
упорядочиваняи выражений. В нем есть как оператор `if`, так и условный оператора `?:`. Если бы все было
выражением в C, вы могли бы объедить их.

Языки, которые избавлюятся от операторов, обычно также имеют неявные возвраты - функция автоматически 
вощвращает любое значение, к которому вычисляется ее тело, без необходимости в каком либо явном синтаксисе
возвара. Для небольших функций, и методов это действительно удобно. Фактически, во многих
яыках, в которых есть оператор, добавлен синтаксис вроде `=>`, чтобы иметь возможность определять функции,
тело которых является результатом вычисления одного выражения.

Но заставить все функции работать таким образом может быть немного странно. Если вы не будете осторожны,
ваша функция даст утечку возвращаемого значения, даже если вы просто хоите, чтобы она производила побочный эффект.
Однако на практике пользователи этих яэыков не считают это проблемой.

[Предыдущая глава](Глава%202%20-%20Карта%20терриотории.md)